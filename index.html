<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Othello AI (Pastel Diagonal + Flip Pop + Mobile Responsive)</title>

  <!-- Bootstrap for layout -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css">
  <!-- Chart.js for the line chart -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>

  <style>
    /* Universal box-sizing for consistent padding/margins */
    * {
      box-sizing: border-box;
    }

    /***********************************************************************
     * Nonâ€“tiling diagonal background
     ***********************************************************************/
    html, body {
      margin: 0;
      padding: 0;
      width: 100%;
      height: 100%;
      font-family: "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
      color: #444;
      overflow-x: hidden;
    }
    body {
      background: linear-gradient(
        135deg,
        #FFF9F2 40%,
        #FFE8D6 40%
      ) no-repeat center center fixed;
      background-size: cover;
    }

    .container {
      max-width: 800px;
      margin: 0 auto;
      padding-top: 30px;
    }

    h1, .text-center {
      color: #444;
    }

    /***********************************************************************
     * Board styling (desktop)
     ***********************************************************************/
    .board {
      max-width: 430px;
      width: 430px;
      display: grid;
      grid-template-columns: repeat(8, 50px);
      grid-template-rows: repeat(8, 50px);
      gap: 2px;
      padding: 8px;
      background: #a5dee5; /* pastel teal */
      box-shadow: 0 2px 8px rgba(0,0,0,0.15);
      border-radius: 8px;
      margin: 0 auto;
      position: relative;
    }

    .cell {
      background: #bae8e8; /* aqua */
      border-radius: 4px;
      position: relative;
      cursor: pointer;
      transition: transform 0.2s ease, background 0.2s ease, box-shadow 0.2s ease;
    }
    .cell:hover {
      transform: scale(1.05);
      background: #98c8c8;
      box-shadow: 0 4px 8px rgba(0,0,0,0.2);
      z-index: 2;
    }

    /* Inset highlight for legal moves */
    .cell.legal {
      box-shadow:
        inset 0 0 0 3px #f19cbb,
        0 4px 8px rgba(0,0,0,0.1);
      z-index: 3;
    }

    /***********************************************************************
     * Piece styling (centered and relative)
     ***********************************************************************/
    .piece {
      width: 80%;
      height: 80%;
      border-radius: 50%;
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      z-index: 4;
    }
    .piece.black {
      background: #3e3e3e;
    }
    .piece.white {
      background: #f9f9f9;
      border: 1px solid #ddd;
    }
    .piece.ghost {
      opacity: 0.5;
    }

    /***********************************************************************
     * Policy heatmap overlay
     ***********************************************************************/
    .heatmap {
      position: absolute;
      top: 0; 
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 1;
      pointer-events: none;
      opacity: 0.5;
      border-radius: 4px;
    }

    /***********************************************************************
     * Flipped highlight
     ***********************************************************************/
    .preview-flip {
      box-shadow: 0 0 0 3px rgba(241, 156, 187, 0.85);
      z-index: 5;
    }

    /***********************************************************************
     * Score bar
     ***********************************************************************/
    .score-bar-container {
      max-width: 430px;
      margin: 15px auto;
    }
    .progress {
      height: 26px;
      border-radius: 4px;
      background-color: #ddd;
      box-shadow: inset 0 1px 2px rgba(0,0,0,0.1);
    }
    .progress-bar {
      font-weight: 500;
      letter-spacing: 0.5px;
    }
    .progress-bar.bg-dark {
      background-color: #F8C471 !important; /* pastel peach */
    }
    .progress-bar.bg-light {
      background-color: #FFE8D6 !important; /* light peach */
      color: #333 !important;
    }

    #status, #remainingStones {
      margin-top: 8px;
    }

    /***********************************************************************
     * Minimal chart container for AI's score
     ***********************************************************************/
    #valueChartContainer {
      max-width: 600px;
      margin: 20px auto;
      padding: 10px;
      border: 2px solid #aaa;
      border-radius: 8px;
      background: #fffefa;
    }
    #valueChart {
      width: 600px;
      height: 300px;
    }

    /***********************************************************************
     * Toggle switches & button styling
     ***********************************************************************/
    .form-switch .form-check-input:checked {
      background-color: #f19cbb !important;
      border-color: #f19cbb !important;
    }
    .form-switch .form-check-input:focus {
      box-shadow: 0 0 0 0.2rem rgba(241,156,187,0.25) !important;
    }
    .btn-primary {
      background-color: #F8C471;
      border-color: #F8C471;
      color: #fff;
    }
    .btn-primary:hover,
    .btn-primary:focus {
      background-color: #F6B05F;
      border-color: #F6B05F;
    }

    /***********************************************************************
     * MOBILE RESPONSIVENESS:
     * Adjust board and chart for small screens.
     ***********************************************************************/
    @media (max-width: 640px) {
      .board {
        width: 90vw;
        max-width: none;
        grid-template-columns: repeat(8, 1fr);
        grid-template-rows: repeat(8, 1fr);
        gap: 4px;       /* Increased gap for a bit more padding between cells */
        padding: 6px;
        margin-bottom: 10px;
      }
      .cell {
        width: auto;
        height: auto;
        aspect-ratio: 1 / 1;
      }
      .score-bar-container,
      #valueChartContainer {
        max-width: 90vw;
      }
      #valueChartContainer {
        margin-top: 10px;
        padding: 8px;
      }
      #valueChart {
        width: 100%;
        height: auto;
      }
      #status, #remainingStones {
        margin-top: 5px;
      }
    }
  </style>
</head>
<body>
  <div class="container">
    <h1 class="text-center mb-4">Othello AI</h1>

    <div class="d-flex justify-content-center mb-3">
      <button id="resetBtn" class="btn btn-primary me-3">Reset Game</button>
      <!-- Hints switch -->
      <div class="form-check form-switch align-self-center me-3">
        <input class="form-check-input" type="checkbox" id="hintsSwitch">
        <label class="form-check-label" for="hintsSwitch">Show Hints</label>
      </div>
      <!-- Policy Brain Visualization Switch -->
      <div class="form-check form-switch align-self-center">
        <input class="form-check-input" type="checkbox" id="agentBrainSwitch">
        <label class="form-check-label" for="agentBrainSwitch">Show AI's Thoughts</label>
      </div>
    </div>

    <!-- Score bar -->
    <div class="score-bar-container">
      <div class="progress">
        <div 
          id="blackScoreBar"
          class="progress-bar bg-dark"
          role="progressbar"
          style="width: 50%;"
          aria-valuenow="50"
          aria-valuemin="0"
          aria-valuemax="100">
          Black: 0
        </div>
        <div 
          id="whiteScoreBar"
          class="progress-bar bg-light text-dark"
          role="progressbar"
          style="width: 50%;"
          aria-valuenow="50"
          aria-valuemin="0"
          aria-valuemax="100">
          White: 0
        </div>
      </div>
    </div>

    <!-- The actual game board -->
    <div id="board" class="board"></div>

    <div id="status" class="text-center"></div>
    <div id="remainingStones" class="text-center"></div>

    <!-- Minimal chart for AI's Score -->
    <div id="valueChartContainer">
      <canvas id="valueChart"></canvas>
    </div>
  </div>

  <!-- ONNX Runtime Web + Chart.js -->
  <script src="https://cdn.jsdelivr.net/npm/onnxruntime-web/dist/ort.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>

  <script>
    const BOARD_SIZE = 8;
    const EMPTY = 0, BLACK = 1, WHITE = -1;
    const NOOP_ACTION = { row: BOARD_SIZE, col: 0 };

    let blackStones, whiteStones;
    let board = [];
    let currentPlayer = BLACK;
    let previousPlayerSkipped = false;
    let gameOver = false;

    // Sessions: one for policy, one for value
    let policySession = null;
    let valueSession = null;

    let hintsEnabled = false;
    let agentBrainEnabled = false;
    let agentProbs = new Array(65).fill(0);

    let previewElements = [];

    // For the line chart
    let valueChart = null;
    let moveCount = 0;

    window.onload = async function() {
      await loadModels();
      setupValueChart();
      await resetGame();

      document.getElementById('hintsSwitch').addEventListener('change', e => {
        hintsEnabled = e.target.checked;
        renderBoard();
      });

      document.getElementById('agentBrainSwitch').addEventListener('change', e => {
        agentBrainEnabled = e.target.checked;
        renderBoard();
      });

      document.getElementById('resetBtn').addEventListener('click', async () => {
        await resetGame();
      });
    };

    async function loadModels() {
      try {
        policySession = await ort.InferenceSession.create('./agent.onnx');
        console.log("Policy model loaded.");
        valueSession = await ort.InferenceSession.create('./value_model.onnx');
        console.log("Value model loaded.");
      } catch (err) {
        console.error("Failed to load model:", err);
        updateStatus("Failed to load ONNX models.");
      }
    }

    function setupValueChart() {
      const ctx = document.getElementById('valueChart').getContext('2d');
      valueChart = new Chart(ctx, {
        type: 'line',
        data: {
          labels: [],
          datasets: [{
            label: '',
            data: [],
            borderColor: 'rgba(75,192,192,1)',
            backgroundColor: 'rgba(75,192,192,0.2)',
            fill: true,
            tension: 0.1,
            pointRadius: 2,
            pointHoverRadius: 3
          }]
        },
        options: {
          plugins: {
            legend: { display: false }
          },
          scales: {
            x: { display: false },
            y: { display: false, min: -1, max: 1 }
          },
          responsive: true,
          maintainAspectRatio: false
        }
      });
    }

    function initBoard() {
      board = Array.from({ length: BOARD_SIZE }, () => Array(BOARD_SIZE).fill(EMPTY));
      const mid = Math.floor(BOARD_SIZE / 2);
      board[mid - 1][mid - 1] = WHITE;
      board[mid][mid] = WHITE;
      board[mid - 1][mid] = BLACK;
      board[mid][mid - 1] = BLACK;

      blackStones = 30;
      whiteStones = 30;
      currentPlayer = BLACK;
      previousPlayerSkipped = false;
      gameOver = false;

      agentProbs.fill(0);
      moveCount = 0;

      if (valueChart) {
        valueChart.data.labels = [];
        valueChart.data.datasets[0].data = [];
        valueChart.update();
      }

      updateStatus("Agent's turn (Black).");
    }

    async function resetGame() {
      initBoard();
      renderBoard();
      await updateValue();
      setTimeout(agentMove, 500);
    }

    function renderBoard() {
      const boardDiv = document.getElementById('board');
      boardDiv.innerHTML = '';
      clearPreview();

      let legalMoves = [];
      if (hintsEnabled && currentPlayer === WHITE) {
        legalMoves = getLegalActions(WHITE).filter(
          m => !(m.row === NOOP_ACTION.row && m.col === NOOP_ACTION.col)
        );
      }

      for (let i = 0; i < BOARD_SIZE; i++) {
        for (let j = 0; j < BOARD_SIZE; j++) {
          const cellDiv = document.createElement('div');
          cellDiv.className = 'cell';
          cellDiv.dataset.row = i;
          cellDiv.dataset.col = j;

          if (legalMoves.some(m => m.row === i && m.col === j)) {
            cellDiv.classList.add('legal');
            cellDiv.addEventListener('mouseenter', () => previewMove(i, j));
            cellDiv.addEventListener('mouseleave', clearPreview);
          }

          cellDiv.addEventListener('click', onCellClick);

          if (board[i][j] === BLACK || board[i][j] === WHITE) {
            const pieceDiv = document.createElement('div');
            pieceDiv.className = 'piece ' + (board[i][j] === BLACK ? 'black' : 'white');
            cellDiv.appendChild(pieceDiv);
          }

          if (agentBrainEnabled) {
            const idx = i * BOARD_SIZE + j;
            const prob = agentProbs[idx];
            if (prob > 0) {
              const heatmapDiv = document.createElement('div');
              heatmapDiv.className = 'heatmap';
              heatmapDiv.style.backgroundColor = getColorForProb(prob);
              cellDiv.appendChild(heatmapDiv);
            }
          }
          boardDiv.appendChild(cellDiv);
        }
      }
      updateScoreBar();
      updateRemainingStonesMessage();
    }

    function previewMove(row, col) {
      if (gameOver || currentPlayer !== WHITE) return;
      const flips = getFlipsIfMove(row, col, WHITE);

      const cellSelector = `[data-row="${row}"][data-col="${col}"]`;
      const cellElem = document.querySelector(cellSelector);
      if (!cellElem) return;

      const ghostPiece = document.createElement('div');
      ghostPiece.className = 'piece white ghost';
      cellElem.appendChild(ghostPiece);
      previewElements.push(ghostPiece);

      flips.forEach(pos => {
        const flipSelector = `[data-row="${pos.row}"][data-col="${pos.col}"] .piece`;
        const piece = document.querySelector(flipSelector);
        if (piece) {
          piece.classList.add('preview-flip');
          previewElements.push(piece);
        }
      });
    }

    function clearPreview() {
      previewElements.forEach(el => {
        if (el.classList.contains('ghost')) {
          el.remove();
        }
        el.classList.remove('preview-flip');
      });
      previewElements = [];
    }

    function getFlipsIfMove(row, col, player) {
      if (board[row][col] !== EMPTY) return [];
      let flips = [];
      for (let di = -1; di <= 1; di++) {
        for (let dj = -1; dj <= 1; dj++) {
          if (di === 0 && dj === 0) continue;
          let k = 1;
          let positionsToFlip = [];
          while (true) {
            let ip = row + k * di, jp = col + k * dj;
            if (ip < 0 || ip >= BOARD_SIZE || jp < 0 || jp >= BOARD_SIZE) break;
            if (board[ip][jp] === EMPTY) break;
            if (board[ip][jp] === -player) {
              positionsToFlip.push({ row: ip, col: jp });
            }
            if (board[ip][jp] === player) {
              if (positionsToFlip.length > 0) {
                flips.push(...positionsToFlip);
              }
              break;
            }
            k++;
          }
        }
      }
      return flips;
    }

    async function agentMove() {
      if (gameOver) return;
      let inputArray = [];
      for (let i = 0; i < BOARD_SIZE; i++) {
        for (let j = 0; j < BOARD_SIZE; j++) {
          inputArray.push(board[i][j]);
        }
      }
      const tensor = new ort.Tensor('float32', Float32Array.from(inputArray), [64]);
      const feeds = {};
      feeds[policySession.inputNames[0]] = tensor;

      try {
        const results = await policySession.run(feeds);
        const outputName = policySession.outputNames[0];
        const logits = results[outputName].data;

        const legal = getLegalActions(BLACK);
        let sumExp = 0;
        let exps = [];
        for (let move of legal) {
          let idx = (move.row === NOOP_ACTION.row && move.col === NOOP_ACTION.col)
            ? 64
            : move.row * BOARD_SIZE + move.col;
          const valExp = Math.exp(logits[idx]);
          exps.push({ index: idx, valExp });
          sumExp += valExp;
        }
        agentProbs.fill(0);
        for (let item of exps) {
          agentProbs[item.index] = item.valExp / sumExp;
        }

        let bestMove = legal[0];
        let bestLogit = -Infinity;
        for (let move of legal) {
          let idx = (move.row === NOOP_ACTION.row && move.col === NOOP_ACTION.col)
            ? 64
            : move.row * BOARD_SIZE + move.col;
          if (logits[idx] > bestLogit) {
            bestLogit = logits[idx];
            bestMove = move;
          }
        }

        let done = applyMove(bestMove);
        renderBoard();
        if (!done) {
          await updateValue();
          updateStatus("Your turn (White).");
          checkHumanAutoSkip();
        } else {
          endGame();
        }
      } catch (err) {
        console.error(err);
        updateStatus("Error in agent move.");
      }
    }

    async function updateValue() {
      let inputArray = [];
      for (let i = 0; i < BOARD_SIZE; i++) {
        for (let j = 0; j < BOARD_SIZE; j++) {
          inputArray.push(board[i][j]);
        }
      }
      const tensor = new ort.Tensor('float32', Float32Array.from(inputArray), [64]);
      const feeds = {};
      feeds[valueSession.inputNames[0]] = tensor;

      try {
        const results = await valueSession.run(feeds);
        const outputName = valueSession.outputNames[0];
        const val = results[outputName].data[0];

        moveCount++;
        if (valueChart) {
          valueChart.data.labels.push(moveCount);
          valueChart.data.datasets[0].data.push(val);
          valueChart.update();
        }
      } catch (err) {
        console.error("Value model error:", err);
      }
    }

    async function onCellClick(e) {
      if (gameOver || currentPlayer !== WHITE) return;
      const row = parseInt(e.currentTarget.dataset.row);
      const col = parseInt(e.currentTarget.dataset.col);
      const legal = getLegalActions(WHITE);
      let valid = legal.some(a => a.row === row && a.col === col);

      if (!valid) {
        updateStatus("Illegal move. Try again.");
        return;
      }
      let ended = applyMove({ row, col });
      renderBoard();
      if (!ended) {
        await updateValue();
        updateStatus("Agent's turn (Black).");
        setTimeout(agentMove, 500);
      } else {
        endGame();
      }
    }

    function checkHumanAutoSkip() {
      const legal = getLegalActions(WHITE);
      if (legal.length === 1 && legal[0].row === NOOP_ACTION.row && legal[0].col === NOOP_ACTION.col) {
        updateStatus("No legal moves available. Skipping your turn...");
        setTimeout(() => {
          let ended = applyMove(NOOP_ACTION);
          renderBoard();
          if (!ended) {
            updateValue();
            updateStatus("Agent's turn (Black).");
            setTimeout(agentMove, 500);
          } else {
            endGame();
          }
        }, 1000);
      }
    }

    function applyMove(action) {
      let done = false;
      if (!(action.row === NOOP_ACTION.row && action.col === NOOP_ACTION.col)) {
        if (currentPlayer === BLACK) blackStones--;
        else whiteStones--;

        const i = action.row, j = action.col;
        board[i][j] = currentPlayer;

        for (let di = -1; di <= 1; di++) {
          for (let dj = -1; dj <= 1; dj++) {
            if (di === 0 && dj === 0) continue;
            let k = 1;
            let positionsToFlip = [];
            while (true) {
              let ip = i + k * di, jp = j + k * dj;
              if (ip < 0 || ip >= BOARD_SIZE || jp < 0 || jp >= BOARD_SIZE) break;
              if (board[ip][jp] === EMPTY) break;
              if (board[ip][jp] === -currentPlayer) {
                positionsToFlip.push({ row: ip, col: jp });
              }
              if (board[ip][jp] === currentPlayer) {
                if (positionsToFlip.length > 0) {
                  positionsToFlip.forEach(pos => {
                    board[pos.row][pos.col] = currentPlayer;
                  });
                }
                break;
              }
              k++;
            }
          }
        }
        previousPlayerSkipped = false;
      } else {
        if (previousPlayerSkipped) done = true;
        previousPlayerSkipped = true;
      }
      if (board.flat().every(cell => cell !== EMPTY)) {
        done = true;
      }
      currentPlayer = -currentPlayer;
      return done;
    }

    function getLegalActions(forPlayer) {
      let legalActions = [];
      if (forPlayer === BLACK) {
        if (blackStones <= 0) {
          legalActions.push(NOOP_ACTION);
          return legalActions;
        }
      } else {
        if (whiteStones <= 0) {
          legalActions.push(NOOP_ACTION);
          return legalActions;
        }
      }

      let openPositions = [];
      for (let i = 0; i < BOARD_SIZE; i++) {
        for (let j = 0; j < BOARD_SIZE; j++) {
          if (board[i][j] === EMPTY) {
            let available = false;
            for (let di = -1; di <= 1; di++) {
              for (let dj = -1; dj <= 1; dj++) {
                if (di === 0 && dj === 0) continue;
                let ni = i + di, nj = j + dj;
                if (ni >= 0 && ni < BOARD_SIZE && nj >= 0 && nj < BOARD_SIZE) {
                  if (board[ni][nj] === -forPlayer) {
                    available = true;
                    break;
                  }
                }
              }
              if (available) break;
            }
            if (available) openPositions.push({ row: i, col: j });
          }
        }
      }

      openPositions.forEach(pos => {
        let valid = false;
        for (let di = -1; di <= 1; di++) {
          for (let dj = -1; dj <= 1; dj++) {
            if (di === 0 && dj === 0) continue;
            for (let k = 1; k < BOARD_SIZE; k++) {
              let ip = pos.row + k * di, jp = pos.col + k * dj;
              if (ip < 0 || ip >= BOARD_SIZE || jp < 0 || jp >= BOARD_SIZE) break;
              if (board[ip][jp] === EMPTY) break;
              if (board[ip][jp] === -forPlayer) {
                // possible flips
              } else if (board[ip][jp] === forPlayer && k >= 2) {
                valid = true;
                break;
              } else {
                break;
              }
            }
            if (valid) break;
          }
          if (valid) legalActions.push({ row: pos.row, col: pos.col });
        }
      });

      if (legalActions.length === 0) legalActions.push(NOOP_ACTION);
      return [...new Set(legalActions.map(JSON.stringify))].map(JSON.parse);
    }

    function endGame() {
      gameOver = true;
      let blackCount = 0, whiteCount = 0;
      board.forEach(row => {
        row.forEach(cell => {
          if (cell === BLACK) blackCount++;
          if (cell === WHITE) whiteCount++;
        });
      });
      let msg = `Game over. Black: ${blackCount}, White: ${whiteCount}. `;
      if (blackCount > whiteCount) {
        msg += "YOU LOSE!";
      } else if (whiteCount > blackCount) {
        msg += "You win!";
      } else {
        msg += "It's a draw!";
      }
      updateStatus(msg);
    }

    function updateRemainingStonesMessage() {
      const msgDiv = document.getElementById('remainingStones');
      if (whiteStones < 3) {
        msgDiv.innerText = `You have ${whiteStones} pieces left.`;
      } else {
        msgDiv.innerText = '';
      }
    }

    function updateScoreBar() {
      let blackCount = 0, whiteCount = 0;
      board.forEach(r => {
        r.forEach(cell => {
          if (cell === BLACK) blackCount++;
          else if (cell === WHITE) whiteCount++;
        });
      });
      const total = blackCount + whiteCount;
      let blackPct = 0, whitePct = 0;
      if (total > 0) {
        blackPct = (blackCount / total) * 100;
        whitePct = (whiteCount / total) * 100;
      }

      const blackBar = document.getElementById('blackScoreBar');
      blackBar.style.width = blackPct + '%';
      blackBar.textContent = `Black: ${blackCount}`;
      blackBar.setAttribute('aria-valuenow', blackPct.toFixed(1));

      const whiteBar = document.getElementById('whiteScoreBar');
      whiteBar.style.width = whitePct + '%';
      whiteBar.textContent = `White: ${whiteCount}`;
      whiteBar.setAttribute('aria-valuenow', whitePct.toFixed(1));
    }

    function updateStatus(msg) {
      document.getElementById('status').innerText = msg;
    }

    function getColorForProb(prob) {
      const startR = 255, startG = 229, startB = 229;
      const endR = 255, endG = 0, endB = 0;
      const r = Math.round(startR + (endR - startR) * prob);
      const g = Math.round(startG + (endG - startG) * prob);
      const b = Math.round(startB + (endB - startB) * prob);
      return `rgb(${r},${g},${b})`;
    }
  </script>
</body>
</html>
