<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Othello AI (Perfect-Fit Board + Hover Preview, Inset Highlight)</title>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css">
  <style>
    body {
      background: #f0f2f5;
      color: #333;
      font-family: "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
    }

    .container {
      max-width: 800px;
      margin: 0 auto;
      padding-top: 20px;
    }

    h1, .text-center {
      color: #333;
    }

    /* 
      The board is a fixed 430px width to exactly fit:
      - 8 columns × 50px each = 400px
      - 7 gaps × 2px = 14px
      - 2×(8px padding) = 16px
      => total 430px
    */
    .board {
      width: 430px;
      display: grid;
      grid-template-columns: repeat(8, 50px);
      grid-template-rows: repeat(8, 50px);
      gap: 2px;
      padding: 8px;
      background: #4caf50;
      box-shadow: 0 2px 8px rgba(0,0,0,0.15);
      border-radius: 8px;
      margin: 0 auto;
      position: relative;
    }

    .cell {
      width: 50px;
      height: 50px;
      background: #66bb6a;
      border-radius: 4px;
      position: relative;
      cursor: pointer;
      transition: background 0.1s ease;
    }
    .cell:hover {
      background: #5da56d;
    }

    /*
      LEGAL MOVE HIGHLIGHT
      Using INSET box-shadow so the ring is drawn *inside* the cell boundary.
    */
    .cell.legal {
      box-shadow: inset 0 0 0 3px #ffeb3b;
      z-index: 2;
    }

    /* Pieces */
    .piece {
      width: 40px;
      height: 40px;
      border-radius: 50%;
      position: absolute;
      top: 5px;
      left: 5px;
      z-index: 2;
    }
    .piece.black {
      background: #2b2b2b;
    }
    .piece.white {
      background: #f9f9f9;
      border: 1px solid #ddd;
    }

    /* A "ghost" piece for hover preview: semitransparent. */
    .piece.ghost {
      opacity: 0.5;
    }

    /* Heatmap overlay for AI Brain */
    .heatmap {
      position: absolute;
      top: 0; left: 0;
      width: 100%;
      height: 100%;
      z-index: 1;
      pointer-events: none;
      opacity: 0.5;
      border-radius: 4px;
    }

    /* For flipping preview, highlight existing pieces with a ring */
    .preview-flip {
      box-shadow: 0 0 0 3px rgba(255, 235, 59, 0.7);
      z-index: 3;
    }

    .score-bar-container {
      max-width: 430px;
      margin: 15px auto;
    }
    .progress {
      height: 26px;
      border-radius: 4px;
      background-color: #ddd;
      box-shadow: inset 0 1px 2px rgba(0,0,0,0.1);
    }
    .progress-bar {
      font-weight: 500;
      letter-spacing: 0.5px;
    }
    .progress-bar.bg-dark {
      background-color: #444 !important;
    }
    .progress-bar.bg-light {
      background-color: #eee !important;
      color: #333 !important;
    }

    #status, #remainingStones {
      margin-top: 8px;
      color: #333;
    }
  </style>
</head>
<body>
  <div class="container">
    <h1 class="text-center mb-4">Othello AI</h1>

    <div class="d-flex justify-content-center mb-3">
      <button id="resetBtn" class="btn btn-primary me-3">Reset Game</button>
      <!-- Hints switch -->
      <div class="form-check form-switch align-self-center me-3">
        <input class="form-check-input" type="checkbox" id="hintsSwitch">
        <label class="form-check-label" for="hintsSwitch">Show Hints</label>
      </div>
      <!-- Agent Brain Visualization Switch -->
      <div class="form-check form-switch align-self-center">
        <input class="form-check-input" type="checkbox" id="agentBrainSwitch">
        <label class="form-check-label" for="agentBrainSwitch">Show AI Brain</label>
      </div>
    </div>

    <div class="score-bar-container">
      <div class="progress">
        <div 
          id="blackScoreBar" 
          class="progress-bar bg-dark" 
          role="progressbar" 
          style="width: 50%;" 
          aria-valuenow="50" 
          aria-valuemin="0" 
          aria-valuemax="100"
        >
          Black: 0
        </div>
        <div 
          id="whiteScoreBar" 
          class="progress-bar bg-light text-dark" 
          role="progressbar" 
          style="width: 50%;" 
          aria-valuenow="50" 
          aria-valuemin="0" 
          aria-valuemax="100"
        >
          White: 0
        </div>
      </div>
    </div>

    <div id="board" class="board"></div>

    <div id="status" class="text-center"></div>
    <div id="remainingStones" class="text-center"></div>
  </div>

  <!-- ONNX Runtime Web -->
  <script src="https://cdn.jsdelivr.net/npm/onnxruntime-web/dist/ort.min.js"></script>
  <script>
    const BOARD_SIZE = 8;
    const EMPTY = 0, BLACK = 1, WHITE = -1;
    const NOOP_ACTION = { row: BOARD_SIZE, col: 0 };

    let blackStones, whiteStones;
    let board = [];
    let currentPlayer = BLACK;
    let previousPlayerSkipped = false;
    let gameOver = false;
    let modelSession = null;

    let hintsEnabled = false;
    let agentBrainEnabled = false;
    let agentProbs = new Array(65).fill(0);

    let previewElements = [];

    function initBoard() {
      board = Array.from({ length: BOARD_SIZE }, () => Array(BOARD_SIZE).fill(EMPTY));
      const mid = Math.floor(BOARD_SIZE / 2);
      board[mid - 1][mid - 1] = WHITE;
      board[mid][mid] = WHITE;
      board[mid - 1][mid] = BLACK;
      board[mid][mid - 1] = BLACK;
      blackStones = 30;
      whiteStones = 30;
      currentPlayer = BLACK;
      previousPlayerSkipped = false;
      gameOver = false;
      agentProbs.fill(0);
      updateStatus("Agent's turn (Black).");
    }

    function renderBoard() {
      const boardDiv = document.getElementById('board');
      boardDiv.innerHTML = '';
      clearPreview();

      let legalMoves = [];
      if (hintsEnabled && currentPlayer === WHITE) {
        legalMoves = getLegalActions(WHITE).filter(
          move => !(move.row === NOOP_ACTION.row && move.col === NOOP_ACTION.col)
        );
      }

      for (let i = 0; i < BOARD_SIZE; i++) {
        for (let j = 0; j < BOARD_SIZE; j++) {
          const cellDiv = document.createElement('div');
          cellDiv.className = 'cell';
          cellDiv.dataset.row = i;
          cellDiv.dataset.col = j;

          // If it's a legal move, highlight + add hover listeners
          if (legalMoves.some(move => move.row === i && move.col === j)) {
            cellDiv.classList.add('legal');
            cellDiv.addEventListener('mouseenter', () => previewMove(i, j));
            cellDiv.addEventListener('mouseleave', clearPreview);
          }

          cellDiv.addEventListener('click', onCellClick);

          // Show existing piece
          if (board[i][j] === BLACK || board[i][j] === WHITE) {
            const pieceDiv = document.createElement('div');
            pieceDiv.className = 'piece ' + (board[i][j] === BLACK ? 'black' : 'white');
            cellDiv.appendChild(pieceDiv);
          }

          // AI Brain heatmap
          if (agentBrainEnabled) {
            const idx = i * BOARD_SIZE + j;
            const prob = agentProbs[idx];
            if (prob > 0) {
              const heatmapDiv = document.createElement('div');
              heatmapDiv.className = 'heatmap';
              heatmapDiv.style.backgroundColor = getColorForProb(prob);
              cellDiv.appendChild(heatmapDiv);
            }
          }

          boardDiv.appendChild(cellDiv);
        }
      }
      updateScoreBar();
      updateRemainingStonesMessage();
    }

    /******************************
     * PREVIEW FLIPS ON HOVER
     ******************************/
    function previewMove(row, col) {
      if (currentPlayer !== WHITE || gameOver) return;
      const flips = getFlipsIfMove(row, col, WHITE);

      // Place a ghost piece in that cell
      const cellSelector = `[data-row="${row}"][data-col="${col}"]`;
      const cellElem = document.querySelector(cellSelector);
      if (!cellElem) return;

      const ghostPiece = document.createElement('div');
      ghostPiece.className = 'piece white ghost';
      cellElem.appendChild(ghostPiece);
      previewElements.push(ghostPiece);

      // Highlight each piece that would flip
      flips.forEach(pos => {
        const flipCellSelector = `[data-row="${pos.row}"][data-col="${pos.col}"] .piece`;
        const piece = document.querySelector(flipCellSelector);
        if (piece) {
          piece.classList.add('preview-flip');
          previewElements.push(piece);
        }
      });
    }

    function clearPreview() {
      previewElements.forEach(el => {
        if (el.classList.contains('ghost')) {
          el.remove();
        }
        el.classList.remove('preview-flip');
      });
      previewElements = [];
    }

    function getFlipsIfMove(row, col, player) {
      if (board[row][col] !== EMPTY) return [];
      let flips = [];
      for (let di = -1; di <= 1; di++) {
        for (let dj = -1; dj <= 1; dj++) {
          if (di === 0 && dj === 0) continue;
          let k = 1;
          let positionsToFlip = [];
          while (true) {
            let ip = row + k * di;
            let jp = col + k * dj;
            if (ip < 0 || ip >= BOARD_SIZE || jp < 0 || jp >= BOARD_SIZE) break;
            if (board[ip][jp] === EMPTY) break;
            if (board[ip][jp] === -player) {
              positionsToFlip.push({ row: ip, col: jp });
            }
            if (board[ip][jp] === player) {
              if (positionsToFlip.length > 0) {
                flips.push(...positionsToFlip);
              }
              break;
            }
            k++;
          }
        }
      }
      return flips;
    }

    function updateRemainingStonesMessage() {
      const msgDiv = document.getElementById('remainingStones');
      if (whiteStones < 3) {
        msgDiv.innerText = `You have ${whiteStones} pieces left.`;
      } else {
        msgDiv.innerText = '';
      }
    }

    function updateScoreBar() {
      let blackCount = 0, whiteCount = 0;
      for (let i = 0; i < BOARD_SIZE; i++) {
        for (let j = 0; j < BOARD_SIZE; j++) {
          if (board[i][j] === BLACK) blackCount++;
          else if (board[i][j] === WHITE) whiteCount++;
        }
      }
      const total = blackCount + whiteCount;
      let blackPct = 0, whitePct = 0;
      if (total > 0) {
        blackPct = (blackCount / total) * 100;
        whitePct = (whiteCount / total) * 100;
      }

      const blackBar = document.getElementById('blackScoreBar');
      blackBar.style.width = blackPct + '%';
      blackBar.textContent = `Black: ${blackCount}`;
      blackBar.setAttribute('aria-valuenow', blackPct.toFixed(1));

      const whiteBar = document.getElementById('whiteScoreBar');
      whiteBar.style.width = whitePct + '%';
      whiteBar.textContent = `White: ${whiteCount}`;
      whiteBar.setAttribute('aria-valuenow', whitePct.toFixed(1));
    }

    function getColorForProb(prob) {
      const startR = 255, startG = 229, startB = 229;
      const endR = 255, endG = 0, endB = 0;
      const r = Math.round(startR + (endR - startR) * prob);
      const g = Math.round(startG + (endG - startG) * prob);
      const b = Math.round(startB + (endB - startB) * prob);
      return `rgb(${r}, ${g}, ${b})`;
    }

    function updateStatus(message) {
      document.getElementById('status').innerText = message;
    }

    /* Main Othello logic */
    function getLegalActions(forPlayer) {
      let legalActions = [];
      if (forPlayer === BLACK) {
        if (blackStones <= 0) {
          legalActions.push(NOOP_ACTION);
          return legalActions;
        }
      } else {
        if (whiteStones <= 0) {
          legalActions.push(NOOP_ACTION);
          return legalActions;
        }
      }

      let openPositions = [];
      for (let i = 0; i < BOARD_SIZE; i++) {
        for (let j = 0; j < BOARD_SIZE; j++) {
          if (board[i][j] === EMPTY) {
            let available = false;
            for (let di = -1; di <= 1; di++) {
              for (let dj = -1; dj <= 1; dj++) {
                if (di === 0 && dj === 0) continue;
                let ni = i + di, nj = j + dj;
                if (ni >= 0 && ni < BOARD_SIZE && nj >= 0 && nj < BOARD_SIZE) {
                  if (board[ni][nj] === -forPlayer) {
                    available = true;
                    break;
                  }
                }
              }
              if (available) break;
            }
            if (available) openPositions.push({ row: i, col: j });
          }
        }
      }

      openPositions.forEach(pos => {
        let valid = false;
        for (let di = -1; di <= 1; di++) {
          for (let dj = -1; dj <= 1; dj++) {
            if (di === 0 && dj === 0) continue;
            for (let k = 1; k < BOARD_SIZE; k++) {
              let ip = pos.row + k * di;
              let jp = pos.col + k * dj;
              if (ip < 0 || ip >= BOARD_SIZE || jp < 0 || jp >= BOARD_SIZE) break;
              if (board[ip][jp] === EMPTY) break;
              if (board[ip][jp] === -forPlayer) {
                // possible flips
              } else if (board[ip][jp] === forPlayer && k >= 2) {
                valid = true;
                break;
              } else {
                break;
              }
            }
            if (valid) break;
          }
          if (valid) legalActions.push({ row: pos.row, col: pos.col });
        }
      });

      if (legalActions.length === 0) legalActions.push(NOOP_ACTION);
      return [...new Set(legalActions.map(JSON.stringify))].map(JSON.parse);
    }

    function applyMove(action) {
      let done = false;
      if (!(action.row === NOOP_ACTION.row && action.col === NOOP_ACTION.col)) {
        if (currentPlayer === BLACK) {
          blackStones--;
        } else {
          whiteStones--;
        }
        const i = action.row, j = action.col;
        board[i][j] = currentPlayer;
        for (let di = -1; di <= 1; di++) {
          for (let dj = -1; dj <= 1; dj++) {
            if (di === 0 && dj === 0) continue;
            let k = 1;
            let positionsToFlip = [];
            while (true) {
              let ip = i + k * di;
              let jp = j + k * dj;
              if (ip < 0 || ip >= BOARD_SIZE || jp < 0 || jp >= BOARD_SIZE) break;
              if (board[ip][jp] === EMPTY) break;
              if (board[ip][jp] === -currentPlayer) {
                positionsToFlip.push({ row: ip, col: jp });
              }
              if (board[ip][jp] === currentPlayer) {
                if (positionsToFlip.length > 0) {
                  positionsToFlip.forEach(pos => {
                    board[pos.row][pos.col] = currentPlayer;
                  });
                }
                break;
              }
              k++;
            }
          }
        }
        previousPlayerSkipped = false;
      } else {
        if (previousPlayerSkipped) {
          done = true;
        }
        previousPlayerSkipped = true;
      }
      if (board.flat().every(cell => cell !== EMPTY)) {
        done = true;
      }
      currentPlayer = -currentPlayer;
      return done;
    }

    async function onCellClick(event) {
      if (gameOver || currentPlayer !== WHITE) return;
      const row = parseInt(event.currentTarget.dataset.row);
      const col = parseInt(event.currentTarget.dataset.col);
      const legal = getLegalActions(WHITE);
      let valid = legal.some(a => a.row === row && a.col === col);
      if (!valid) {
        updateStatus("Illegal move. Try again.");
        return;
      }
      let gameEnded = applyMove({ row, col });
      renderBoard();
      if (gameEnded) {
        endGame();
        return;
      }
      updateStatus("Agent's turn (Black).");
      setTimeout(agentMove, 500);
    }

    async function agentMove() {
      if (gameOver) return;

      let inputArray = [];
      for (let i = 0; i < BOARD_SIZE; i++) {
        for (let j = 0; j < BOARD_SIZE; j++) {
          inputArray.push(board[i][j]);
        }
      }
      const tensor = new ort.Tensor('float32', Float32Array.from(inputArray), [64]);
      const feeds = {};
      feeds[modelSession.inputNames[0]] = tensor;

      try {
        const results = await modelSession.run(feeds);
        const outputName = modelSession.outputNames[0];
        const logits = results[outputName].data;

        const legal = getLegalActions(BLACK);
        let sumExp = 0;
        let exps = [];
        for (let move of legal) {
          let index = (move.row === NOOP_ACTION.row && move.col === NOOP_ACTION.col)
            ? 64 : move.row * BOARD_SIZE + move.col;
          const valExp = Math.exp(logits[index]);
          exps.push({ index, valExp });
          sumExp += valExp;
        }
        agentProbs.fill(0);
        for (let item of exps) {
          agentProbs[item.index] = item.valExp / sumExp;
        }

        let bestMove = legal[0];
        let bestLogit = -Infinity;
        for (let move of legal) {
          let idx = (move.row === NOOP_ACTION.row && move.col === NOOP_ACTION.col)
            ? 64 : move.row * BOARD_SIZE + move.col;
          if (logits[idx] > bestLogit) {
            bestLogit = logits[idx];
            bestMove = move;
          }
        }

        let gameEnded = applyMove(bestMove);
        renderBoard();
        if (gameEnded) {
          endGame();
          return;
        }
        updateStatus("Your turn (White).");
        checkHumanAutoSkip();
      } catch (err) {
        console.error(err);
        updateStatus("Error in agent move.");
      }
    }

    function checkHumanAutoSkip() {
      const legal = getLegalActions(WHITE);
      if (legal.length === 1 && legal[0].row === NOOP_ACTION.row && legal[0].col === NOOP_ACTION.col) {
        updateStatus("No legal moves available. Skipping your turn...");
        setTimeout(() => {
          let gameEnded = applyMove(NOOP_ACTION);
          renderBoard();
          if (gameEnded) {
            endGame();
            return;
          }
          updateStatus("Agent's turn (Black).");
          setTimeout(agentMove, 500);
        }, 1000);
      }
    }

    function endGame() {
      gameOver = true;
      let blackCount = 0, whiteCount = 0;
      board.forEach(row => {
        row.forEach(cell => {
          if (cell === BLACK) blackCount++;
          if (cell === WHITE) whiteCount++;
        });
      });
      let message = `Game over. Black: ${blackCount}, White: ${whiteCount}. `;
      if (blackCount > whiteCount) {
        message += "YOU LOSE!";
      } else if (whiteCount > blackCount) {
        message += "You win!";
      } else {
        message += "It's a draw!";
      }
      updateStatus(message);
    }

    function resetGame() {
      initBoard();
      renderBoard();
      setTimeout(agentMove, 500);
    }

    async function loadModel() {
      try {
        modelSession = await ort.InferenceSession.create('./agent.onnx');
        console.log("Model loaded.");
      } catch (err) {
        console.error("Failed to load model:", err);
        updateStatus("Failed to load ONNX model.");
      }
    }

    window.onload = async function() {
      await loadModel();
      resetGame();

      document.getElementById('hintsSwitch').addEventListener('change', function(event) {
        hintsEnabled = event.target.checked;
        renderBoard();
      });

      document.getElementById('agentBrainSwitch').addEventListener('change', function(event) {
        agentBrainEnabled = event.target.checked;
        renderBoard();
      });
    };

    document.getElementById('resetBtn').addEventListener('click', resetGame);
  </script>
</body>
</html>
