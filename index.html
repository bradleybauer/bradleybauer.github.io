<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Othello AI with Brain Visualization</title>
  <!-- Using Bootstrap for a modern, responsive layout -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css">
  <style>
    body {
      background: #f8f9fa;
    }
    .board {
      display: grid;
      grid-template-columns: repeat(8, 50px);
      grid-template-rows: repeat(8, 50px);
      gap: 2px;
      margin: 20px auto;
      max-width: 420px; /* board width */
      position: relative;
    }
    .cell {
      width: 50px;
      height: 50px;
      background: green;
      border: 1px solid #333;
      position: relative;
      cursor: pointer;
      overflow: hidden;
    }
    /* Highlight legal moves with a yellow border */
    .cell.legal {
      border: 3px solid yellow;
    }
    .piece {
      width: 40px;
      height: 40px;
      border-radius: 50%;
      position: absolute;
      top: 5px;
      left: 5px;
      z-index: 2;
    }
    .piece.black {
      background: black;
    }
    .piece.white {
      background: white;
      border: 1px solid #333;
    }

    /* Heatmap for AI Brain Visualization */
    .heatmap {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 1;
      pointer-events: none;
      opacity: 0.65;
    }
  </style>
</head>
<body>
  <div class="container">
    <h1 class="text-center my-4">Othello AI</h1>
    <div class="d-flex justify-content-center mb-3">
      <button id="resetBtn" class="btn btn-primary me-3">Reset Game</button>
      <!-- Hints switch -->
      <div class="form-check form-switch align-self-center me-3">
        <input class="form-check-input" type="checkbox" id="hintsSwitch">
        <label class="form-check-label" for="hintsSwitch">Show Hints</label>
      </div>
      <!-- Agent Brain Visualization Switch -->
      <div class="form-check form-switch align-self-center">
        <input class="form-check-input" type="checkbox" id="agentBrainSwitch">
        <label class="form-check-label" for="agentBrainSwitch">Show AI Brain</label>
      </div>
    </div>
    
    <!-- Score Bar (same width as the board) -->
    <div class="mx-auto mb-3" style="max-width: 420px;">
      <div class="progress" style="height: 30px;">
        <div 
          id="blackScoreBar" 
          class="progress-bar bg-dark" 
          role="progressbar" 
          style="width: 50%;" 
          aria-valuenow="50" 
          aria-valuemin="0" 
          aria-valuemax="100"
        >
          Black: 0
        </div>
        <div 
          id="whiteScoreBar" 
          class="progress-bar bg-light text-dark" 
          role="progressbar" 
          style="width: 50%;" 
          aria-valuenow="50" 
          aria-valuemin="0" 
          aria-valuemax="100"
        >
          White: 0
        </div>
      </div>
    </div>

    <div id="board" class="board"></div>

    <!-- Status messages -->
    <div id="status" class="text-center mt-3"></div>
    <!-- NEW: Show "You have X pieces left" only if X < 3 -->
    <div id="remainingStones" class="text-center mt-2"></div>
  </div>

  <!-- ONNX Runtime Web -->
  <script src="https://cdn.jsdelivr.net/npm/onnxruntime-web/dist/ort.min.js"></script>
  <script>
    const BOARD_SIZE = 8;
    const EMPTY = 0, BLACK = 1, WHITE = -1;
    const NOOP_ACTION = { row: BOARD_SIZE, col: 0 };

    let blackStones, whiteStones;
    let board = [];
    let currentPlayer = BLACK;
    let previousPlayerSkipped = false;
    let gameOver = false;
    let modelSession = null;

    let hintsEnabled = false; 
    let agentBrainEnabled = false; 
    let agentProbs = new Array(65).fill(0);

    // Initialize the board, set counters, etc.
    function initBoard() {
      board = Array.from({ length: BOARD_SIZE }, () => Array(BOARD_SIZE).fill(EMPTY));
      const mid = Math.floor(BOARD_SIZE / 2);
      board[mid - 1][mid - 1] = WHITE;
      board[mid][mid] = WHITE;
      board[mid - 1][mid] = BLACK;
      board[mid][mid - 1] = BLACK;
      blackStones = 30;
      whiteStones = 30;
      currentPlayer = BLACK;
      previousPlayerSkipped = false;
      gameOver = false;
      agentProbs.fill(0);
      updateStatus("Agent's turn (Black).");
    }

    // Called after each move to re-draw the board
    function renderBoard() {
      const boardDiv = document.getElementById('board');
      boardDiv.innerHTML = '';

      // If it's your turn (WHITE) and hints are enabled, compute legal moves
      let legalMoves = [];
      if (hintsEnabled && currentPlayer === WHITE) {
        legalMoves = getLegalActions(WHITE).filter(
          move => !(move.row === NOOP_ACTION.row && move.col === NOOP_ACTION.col)
        );
      }

      for (let i = 0; i < BOARD_SIZE; i++) {
        for (let j = 0; j < BOARD_SIZE; j++) {
          const cellDiv = document.createElement('div');
          cellDiv.className = 'cell';
          cellDiv.dataset.row = i;
          cellDiv.dataset.col = j;
          cellDiv.addEventListener('click', onCellClick);

          // Highlight if it's a legal move (human + hints)
          if (legalMoves.some(move => move.row === i && move.col === j)) {
            cellDiv.classList.add('legal');
          }

          // Draw any piece
          if (board[i][j] === BLACK || board[i][j] === WHITE) {
            const pieceDiv = document.createElement('div');
            pieceDiv.className = 'piece ' + (board[i][j] === BLACK ? 'black' : 'white');
            cellDiv.appendChild(pieceDiv);
          }

          // If Agent Brain is on, overlay probability heatmap
          if (agentBrainEnabled) {
            const idx = i * BOARD_SIZE + j;
            const prob = agentProbs[idx];
            if (prob > 0) {
              const heatmapDiv = document.createElement('div');
              heatmapDiv.className = 'heatmap';
              heatmapDiv.style.backgroundColor = getColorForProb(prob);
              cellDiv.appendChild(heatmapDiv);
            }
          }
          boardDiv.appendChild(cellDiv);
        }
      }
      // Update the stacked bar, also show/hide "You have X left" if X<3
      updateScoreBar();
      updateRemainingStonesMessage();
    }

    // Show "You have X pieces left" only if X < 3
    function updateRemainingStonesMessage() {
      const msgDiv = document.getElementById('remainingStones');
      if (whiteStones < 3) {
        msgDiv.innerText = `You have ${whiteStones} pieces left.`;
      } else {
        msgDiv.innerText = '';
      }
    }

    // Update the stacked bar with the number of black/white discs ON THE BOARD
    function updateScoreBar() {
      let blackCount = 0, whiteCount = 0;
      for (let i = 0; i < BOARD_SIZE; i++) {
        for (let j = 0; j < BOARD_SIZE; j++) {
          if (board[i][j] === BLACK) blackCount++;
          else if (board[i][j] === WHITE) whiteCount++;
        }
      }
      const total = blackCount + whiteCount;
      let blackPct = 0, whitePct = 0;
      if (total > 0) {
        blackPct = (blackCount / total) * 100;
        whitePct = (whiteCount / total) * 100;
      }

      const blackBar = document.getElementById('blackScoreBar');
      blackBar.style.width = blackPct + '%';
      blackBar.textContent = `Black: ${blackCount}`;
      blackBar.setAttribute('aria-valuenow', blackPct.toFixed(1));

      const whiteBar = document.getElementById('whiteScoreBar');
      whiteBar.style.width = whitePct + '%';
      whiteBar.textContent = `White: ${whiteCount}`;
      whiteBar.setAttribute('aria-valuenow', whitePct.toFixed(1));
    }

    // Map probability to a color (light pink => bright red)
    function getColorForProb(prob) {
      const startR = 255, startG = 229, startB = 229; // light pink
      const endR = 255, endG = 0, endB = 0;          // red
      const r = Math.round(startR + (endR - startR) * prob);
      const g = Math.round(startG + (endG - startG) * prob);
      const b = Math.round(startB + (endB - startB) * prob);
      return `rgb(${r}, ${g}, ${b})`;
    }

    // Utility: update status text
    function updateStatus(message) {
      document.getElementById('status').innerText = message;
    }

    // Get list of legal moves for a player
    function getLegalActions(forPlayer) {
      let legalActions = [];
      if (forPlayer === BLACK) {
        if (blackStones <= 0) {
          legalActions.push(NOOP_ACTION);
          return legalActions;
        }
      } else {
        if (whiteStones <= 0) {
          legalActions.push(NOOP_ACTION);
          return legalActions;
        }
      }
      
      let openPositions = [];
      for (let i = 0; i < BOARD_SIZE; i++) {
        for (let j = 0; j < BOARD_SIZE; j++) {
          if (board[i][j] === EMPTY) {
            let available = false;
            for (let di = -1; di <= 1; di++) {
              for (let dj = -1; dj <= 1; dj++) {
                if (di === 0 && dj === 0) continue;
                let ni = i + di, nj = j + dj;
                if (ni >= 0 && ni < BOARD_SIZE && nj >= 0 && nj < BOARD_SIZE) {
                  if (board[ni][nj] === -forPlayer) {
                    available = true;
                    break;
                  }
                }
              }
              if (available) break;
            }
            if (available) openPositions.push({ row: i, col: j });
          }
        }
      }
      
      openPositions.forEach(pos => {
        let valid = false;
        for (let di = -1; di <= 1; di++) {
          for (let dj = -1; dj <= 1; dj++) {
            if (di === 0 && dj === 0) continue;
            for (let k = 1; k < BOARD_SIZE; k++) {
              let ip = pos.row + k * di, jp = pos.col + k * dj;
              if (ip < 0 || ip >= BOARD_SIZE || jp < 0 || jp >= BOARD_SIZE) break;
              if (board[ip][jp] === EMPTY) break;
              if (board[ip][jp] === -forPlayer) {
                // Keep track, might flip
              } else if (board[ip][jp] === forPlayer && k >= 2) {
                valid = true;
                break;
              } else {
                break;
              }
            }
            if (valid) break;
          }
          if (valid) legalActions.push({ row: pos.row, col: pos.col });
        }
      });

      if (legalActions.length === 0) legalActions.push(NOOP_ACTION);
      return [...new Set(legalActions.map(JSON.stringify))].map(JSON.parse);
    }

    // Place a stone (if not NOOP), flip, etc.
    function applyMove(action) {
      let done = false;
      if (!(action.row === NOOP_ACTION.row && action.col === NOOP_ACTION.col)) {
        if (currentPlayer === BLACK) {
          blackStones--;
        } else {
          whiteStones--;
        }
        const i = action.row, j = action.col;
        board[i][j] = currentPlayer;
        for (let di = -1; di <= 1; di++) {
          for (let dj = -1; dj <= 1; dj++) {
            if (di === 0 && dj === 0) continue;
            let k = 1;
            let positionsToFlip = [];
            while (true) {
              let ip = i + k * di, jp = j + k * dj;
              if (ip < 0 || ip >= BOARD_SIZE || jp < 0 || jp >= BOARD_SIZE) break;
              if (board[ip][jp] === EMPTY) break;
              if (board[ip][jp] === -currentPlayer) {
                positionsToFlip.push({ row: ip, col: jp });
              }
              if (board[ip][jp] === currentPlayer) {
                if (positionsToFlip.length > 0) {
                  positionsToFlip.forEach(pos => {
                    board[pos.row][pos.col] = currentPlayer;
                  });
                }
                break;
              }
              k++;
            }
          }
        }
        previousPlayerSkipped = false;
      } else {
        // It's a NOOP move
        if (previousPlayerSkipped) {
          done = true;
        }
        previousPlayerSkipped = true;
      }
      if (board.flat().every(cell => cell !== EMPTY)) {
        done = true;
      }
      currentPlayer = -currentPlayer;
      return done;
    }

    // Human move
    async function onCellClick(event) {
      if (gameOver || currentPlayer !== WHITE) return;
      const row = parseInt(event.currentTarget.dataset.row);
      const col = parseInt(event.currentTarget.dataset.col);
      const legal = getLegalActions(WHITE);
      let valid = legal.some(a => a.row === row && a.col === col);
      if (!valid) {
        updateStatus("Illegal move. Try again.");
        return;
      }
      let gameEnded = applyMove({ row, col });
      renderBoard();
      if (gameEnded) {
        endGame();
        return;
      }
      updateStatus("Agent's turn (Black).");
      setTimeout(agentMove, 500);
    }

    // AI move
    async function agentMove() {
      if (gameOver) return;
      // Flatten board to 1D
      let inputArray = [];
      for (let i = 0; i < BOARD_SIZE; i++) {
        for (let j = 0; j < BOARD_SIZE; j++) {
          inputArray.push(board[i][j]);
        }
      }
      const tensor = new ort.Tensor('float32', Float32Array.from(inputArray), [64]);
      const feeds = {};
      feeds[modelSession.inputNames[0]] = tensor;

      try {
        const results = await modelSession.run(feeds);
        const outputName = modelSession.outputNames[0];
        const logits = results[outputName].data;
        const legal = getLegalActions(BLACK);

        // Softmax among legal moves
        let sumExp = 0;
        let exps = [];
        for (let move of legal) {
          let index = (move.row === NOOP_ACTION.row && move.col === NOOP_ACTION.col)
            ? 64 : move.row * BOARD_SIZE + move.col;
          const valExp = Math.exp(logits[index]);
          exps.push({ index, valExp });
          sumExp += valExp;
        }
        agentProbs.fill(0);
        for (let item of exps) {
          agentProbs[item.index] = item.valExp / sumExp;
        }

        // Pick best move (highest logit)
        let bestMove = legal[0];
        let bestLogit = -Infinity;
        for (let move of legal) {
          let idx = (move.row === NOOP_ACTION.row && move.col === NOOP_ACTION.col)
            ? 64 : move.row * BOARD_SIZE + move.col;
          if (logits[idx] > bestLogit) {
            bestLogit = logits[idx];
            bestMove = move;
          }
        }
        let gameEnded = applyMove(bestMove);
        renderBoard();
        if (gameEnded) {
          endGame();
          return;
        }
        updateStatus("Your turn (White).");
        checkHumanAutoSkip();
      } catch (err) {
        console.error(err);
        updateStatus("Error in agent move.");
      }
    }

    // Auto-skip if White has no legal moves
    function checkHumanAutoSkip() {
      const legal = getLegalActions(WHITE);
      if (legal.length === 1 && legal[0].row === NOOP_ACTION.row && legal[0].col === NOOP_ACTION.col) {
        updateStatus("No legal moves available. Skipping your turn...");
        setTimeout(() => {
          let gameEnded = applyMove(NOOP_ACTION);
          renderBoard();
          if (gameEnded) {
            endGame();
            return;
          }
          updateStatus("Agent's turn (Black).");
          setTimeout(agentMove, 500);
        }, 1000);
      }
    }

    // End-of-game status
    function endGame() {
      gameOver = true;
      let blackCount = 0, whiteCount = 0;
      board.forEach(row => {
        row.forEach(cell => {
          if (cell === BLACK) blackCount++;
          if (cell === WHITE) whiteCount++;
        });
      });
      let message = `Game over. Black: ${blackCount}, White: ${whiteCount}. `;
      if (blackCount > whiteCount) {
        message += "YOU LOSE!";
      } else if (whiteCount > blackCount) {
        message += "You win!";
      } else {
        message += "It's a draw!";
      }
      updateStatus(message);
    }

    // Reset + start agent's move
    function resetGame() {
      initBoard();
      renderBoard();
      setTimeout(agentMove, 500);
    }

    // Load ONNX model
    async function loadModel() {
      try {
        modelSession = await ort.InferenceSession.create('./agent.onnx');
        console.log("Model loaded.");
      } catch (err) {
        console.error("Failed to load model:", err);
        updateStatus("Failed to load ONNX model.");
      }
    }

    // On load
    window.onload = async function() {
      await loadModel();
      resetGame();

      document.getElementById('hintsSwitch').addEventListener('change', function(event) {
        hintsEnabled = event.target.checked;
        renderBoard();
      });

      document.getElementById('agentBrainSwitch').addEventListener('change', function(event) {
        agentBrainEnabled = event.target.checked;
        renderBoard();
      });
    };

    document.getElementById('resetBtn').addEventListener('click', resetGame);
  </script>
</body>
</html>
