<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Othello AI</title>
  <!-- Using Bootstrap for a modern, responsive layout -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css">
  <style>
    body {
      background: #f8f9fa;
    }
    .board {
      display: grid;
      grid-template-columns: repeat(8, 50px);
      grid-template-rows: repeat(8, 50px);
      gap: 2px;
      margin: 20px auto;
      max-width: 420px;
    }
    .cell {
      width: 50px;
      height: 50px;
      background: green;
      border: 1px solid #333;
      position: relative;
      cursor: pointer;
    }
    /* Highlight legal moves with a yellow border */
    .cell.legal {
      border: 3px solid yellow;
    }
    .piece {
      width: 40px;
      height: 40px;
      border-radius: 50%;
      position: absolute;
      top: 5px;
      left: 5px;
    }
    .piece.black {
      background: black;
    }
    .piece.white {
      background: white;
      border: 1px solid #333;
    }
  </style>
</head>
<body>
  <div class="container">
    <h1 class="text-center my-4">Othello AI</h1>
    <div class="d-flex justify-content-center mb-3">
      <button id="resetBtn" class="btn btn-primary me-3">Reset Game</button>
      <!-- Hints switch -->
      <div class="form-check form-switch align-self-center">
        <input class="form-check-input" type="checkbox" id="hintsSwitch">
        <label class="form-check-label" for="hintsSwitch">Show Hints</label>
      </div>
    </div>
    <!-- Counters for remaining pieces -->
    <div id="counters" class="text-center mb-3"></div>
    <div id="board" class="board"></div>
    <div id="status" class="text-center mt-3"></div>
  </div>

  <!-- ONNX Runtime Web -->
  <script src="https://cdn.jsdelivr.net/npm/onnxruntime-web/dist/ort.min.js"></script>
  <script>
    // Global constants and game state.
    const BOARD_SIZE = 8;
    const EMPTY = 0, BLACK = 1, WHITE = -1;
    // Using (8,0) as the no–move action.
    const NOOP_ACTION = { row: BOARD_SIZE, col: 0 };

    // Each player starts with 32 stones, but 2 are on the board, so 30 remain.
    let blackStones, whiteStones;
    let board = [];
    // Set currentPlayer = BLACK so that the agent (black) goes first.
    let currentPlayer = BLACK;
    let previousPlayerSkipped = false;
    let gameOver = false;
    let modelSession = null;
    let hintsEnabled = false; // Hints switch off by default.

    // Update counters display.
    function updateCounters() {
      document.getElementById('counters').innerHTML =
        `Black Pieces Remaining (Agent): ${blackStones} &nbsp; | &nbsp; White Pieces Remaining (You): ${whiteStones}`;
    }

    // Initialize the board and stone counts.
    function initBoard() {
      board = Array.from({ length: BOARD_SIZE }, () => Array(BOARD_SIZE).fill(EMPTY));
      const mid = Math.floor(BOARD_SIZE / 2);
      board[mid - 1][mid - 1] = WHITE;
      board[mid][mid] = WHITE;
      board[mid - 1][mid] = BLACK;
      board[mid][mid - 1] = BLACK;
      blackStones = 30;
      whiteStones = 30;
      // Agent is Black, so agent goes first.
      currentPlayer = BLACK;
      previousPlayerSkipped = false;
      gameOver = false;
      updateStatus("Agent's turn (Black).");
    }

    // Render the board UI and, if hints are enabled and it's the human's turn (White), highlight legal moves.
    function renderBoard() {
      const boardDiv = document.getElementById('board');
      boardDiv.innerHTML = '';

      // Compute legal moves only if hints are enabled and it's the human's turn.
      let legalMoves = [];
      if (hintsEnabled && currentPlayer === WHITE) {
        legalMoves = getLegalActions(WHITE).filter(
          move => !(move.row === NOOP_ACTION.row && move.col === NOOP_ACTION.col)
        );
      }

      for (let i = 0; i < BOARD_SIZE; i++) {
        for (let j = 0; j < BOARD_SIZE; j++) {
          const cellDiv = document.createElement('div');
          cellDiv.className = 'cell';
          cellDiv.dataset.row = i;
          cellDiv.dataset.col = j;
          cellDiv.addEventListener('click', onCellClick);
          if (legalMoves.some(move => move.row === i && move.col === j)) {
            cellDiv.classList.add('legal');
          }
          if (board[i][j] === BLACK || board[i][j] === WHITE) {
            const pieceDiv = document.createElement('div');
            pieceDiv.className = 'piece ' + (board[i][j] === BLACK ? 'black' : 'white');
            cellDiv.appendChild(pieceDiv);
          }
          boardDiv.appendChild(cellDiv);
        }
      }
      updateCounters();
    }

    // Update the status display.
    function updateStatus(message) {
      document.getElementById('status').innerText = message;
    }

    // Compute legal actions for a given player (mirroring the Python Othello.get_legal_actions).
    function getLegalActions(forPlayer) {
      let legalActions = [];
      // If out of stones, only no–op is allowed.
      if (forPlayer === BLACK) {
        if (blackStones <= 0) {
          legalActions.push(NOOP_ACTION);
          return legalActions;
        }
      } else {
        if (whiteStones <= 0) {
          legalActions.push(NOOP_ACTION);
          return legalActions;
        }
      }
      
      // Find empty positions adjacent to an enemy.
      let openPositions = [];
      for (let i = 0; i < BOARD_SIZE; i++) {
        for (let j = 0; j < BOARD_SIZE; j++) {
          if (board[i][j] === EMPTY) {
            let available = false;
            for (let di = -1; di <= 1; di++) {
              for (let dj = -1; dj <= 1; dj++) {
                if (di === 0 && dj === 0) continue;
                let ni = i + di, nj = j + dj;
                if (ni >= 0 && ni < BOARD_SIZE && nj >= 0 && nj < BOARD_SIZE) {
                  if (board[ni][nj] === -forPlayer) {
                    available = true;
                    break;
                  }
                }
              }
              if (available) break;
            }
            if (available) {
              openPositions.push({ row: i, col: j });
            }
          }
        }
      }
      
      // Validate candidate moves using flipping rules.
      openPositions.forEach(pos => {
        let valid = false;
        for (let di = -1; di <= 1; di++) {
          for (let dj = -1; dj <= 1; dj++) {
            if (di === 0 && dj === 0) continue;
            for (let k = 1; k < BOARD_SIZE; k++) {
              let ip = pos.row + k * di, jp = pos.col + k * dj;
              if (ip < 0 || ip >= BOARD_SIZE || jp < 0 || jp >= BOARD_SIZE) break;
              if (k >= 2 && board[ip][jp] === forPlayer) {
                valid = true;
                break;
              }
              if (board[ip][jp] !== -forPlayer) {
                break;
              }
            }
            if (valid) break;
          }
          if (valid) break;
        }
        if (valid) legalActions.push({ row: pos.row, col: pos.col });
      });
      if (legalActions.length === 0) legalActions.push(NOOP_ACTION);
      return legalActions;
    }

    // Apply a move (mirroring Python Othello.step).
    function applyMove(action) {
      let done = false;
      if (!(action.row === NOOP_ACTION.row && action.col === NOOP_ACTION.col)) {
        if (currentPlayer === BLACK) {
          blackStones--;
        } else {
          whiteStones--;
        }
        const i = action.row, j = action.col;
        board[i][j] = currentPlayer;
        for (let di = -1; di <= 1; di++) {
          for (let dj = -1; dj <= 1; dj++) {
            if (di === 0 && dj === 0) continue;
            let k = 1;
            let positionsToFlip = [];
            while (true) {
              let ip = i + k * di, jp = j + k * dj;
              if (ip < 0 || ip >= BOARD_SIZE || jp < 0 || jp >= BOARD_SIZE) break;
              if (board[ip][jp] === EMPTY) break;
              if (board[ip][jp] === -currentPlayer) {
                positionsToFlip.push({ row: ip, col: jp });
              }
              if (board[ip][jp] === currentPlayer) {
                if (positionsToFlip.length > 0) {
                  positionsToFlip.forEach(pos => {
                    board[pos.row][pos.col] = currentPlayer;
                  });
                }
                break;
              }
              k++;
            }
          }
        }
        previousPlayerSkipped = false;
      } else {
        if (previousPlayerSkipped) {
          done = true;
        }
        previousPlayerSkipped = true;
      }
      if (board.flat().every(cell => cell !== EMPTY)) {
        done = true;
      }
      // Switch turn: agent is Black, human is White.
      currentPlayer = -currentPlayer;
      return done;
    }

    // Human click handler. Only allow clicks when it's the human's turn (White).
    async function onCellClick(event) {
      if (gameOver || currentPlayer !== WHITE) return;
      const row = parseInt(event.currentTarget.dataset.row);
      const col = parseInt(event.currentTarget.dataset.col);
      const legal = getLegalActions(WHITE);
      let valid = legal.some(a => a.row === row && a.col === col);
      if (!valid) {
        updateStatus("Illegal move. Try again.");
        return;
      }
      let gameEnded = applyMove({ row, col });
      renderBoard();
      if (gameEnded) {
        endGame();
        return;
      }
      updateStatus("Agent's turn (Black).");
      setTimeout(agentMove, 500);
    }

    // Agent move: selects (among valid moves for Black) the one with the highest logit.
    async function agentMove() {
      if (gameOver) return;
      let inputArray = [];
      for (let i = 0; i < BOARD_SIZE; i++) {
        for (let j = 0; j < BOARD_SIZE; j++) {
          inputArray.push(board[i][j]);
        }
      }
      // Input is a 1x64 tensor.
      const tensor = new ort.Tensor('float32', Float32Array.from(inputArray), [64]);
      let feeds = {};
      const inputName = modelSession.inputNames[0];
      feeds[inputName] = tensor;
      try {
        const results = await modelSession.run(feeds);
        const outputName = modelSession.outputNames[0];
        const logits = results[outputName].data;
        const legal = getLegalActions(BLACK);
        let bestMove = legal[0];
        let bestLogit = -Infinity;
        for (let move of legal) {
          let index;
          if (move.row === NOOP_ACTION.row && move.col === NOOP_ACTION.col) {
            index = 64;
          } else {
            index = move.row * 8 + move.col;
          }
          if (logits[index] > bestLogit) {
            bestLogit = logits[index];
            bestMove = move;
          }
        }
        let gameEnded = applyMove(bestMove);
        renderBoard();
        if (gameEnded) {
          endGame();
          return;
        }
        updateStatus("Your turn (White).");
        checkHumanAutoSkip();
      } catch (err) {
        console.error(err);
        updateStatus("Error in agent move.");
      }
    }

    // Auto-skip human turn if no legal moves exist for White.
    function checkHumanAutoSkip() {
      const legal = getLegalActions(WHITE);
      if (legal.length === 1 && legal[0].row === NOOP_ACTION.row && legal[0].col === NOOP_ACTION.col) {
        updateStatus("No legal moves available. Skipping your turn...");
        setTimeout(() => {
          let gameEnded = applyMove(NOOP_ACTION);
          renderBoard();
          if (gameEnded) {
            endGame();
            return;
          }
          updateStatus("Agent's turn (Black).");
          setTimeout(agentMove, 500);
        }, 1000);
      }
    }

    // End-of-game status.
    function endGame() {
      gameOver = true;
      let blackCount = 0, whiteCount = 0;
      board.forEach(row => {
        row.forEach(cell => {
          if (cell === BLACK) blackCount++;
          if (cell === WHITE) whiteCount++;
        });
      });
      let message = `Game over. Black: ${blackCount}, White: ${whiteCount}. `;
      if (blackCount > whiteCount) {
        message += "YOU LOSE!";
      } else if (whiteCount > blackCount) {
        message += "You win!";
      } else {
        message += "It's a draw!";
      }
      updateStatus(message);
    }

    // Reset the game.
    function resetGame() {
      initBoard();
      renderBoard();
      // Since agent is Black and goes first, immediately trigger the agent move.
      setTimeout(agentMove, 500);
    }

    // Load the ONNX model (ensure agent.onnx is in the same directory).
    async function loadModel() {
      try {
        modelSession = await ort.InferenceSession.create('./agent.onnx');
        console.log("Model loaded.");
      } catch (err) {
        console.error("Failed to load model:", err);
        updateStatus("Failed to load ONNX model.");
      }
    }

    window.onload = async function() {
      await loadModel();
      resetGame();
      document.getElementById('hintsSwitch').addEventListener('change', function(event) {
        hintsEnabled = event.target.checked;
        renderBoard();
      });
    };

    document.getElementById('resetBtn').addEventListener('click', resetGame);
  </script>
</body>
</html>
